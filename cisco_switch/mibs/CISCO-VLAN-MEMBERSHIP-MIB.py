# PySNMP SMI module. Autogenerated from smidump -f python CISCO-VLAN-MEMBERSHIP-MIB
# by libsmi2pysnmp-0.1.3 at Sat Jun  6 17:03:24 2015,
# Python version sys.version_info(major=2, minor=7, micro=6, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( ciscoMgmt, ) = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
( CiscoPortList, CiscoPortListRange, ) = mibBuilder.importSymbols("CISCO-TC", "CiscoPortList", "CiscoPortListRange")
( VlanIndex, ) = mibBuilder.importSymbols("CISCO-VTP-MIB", "VlanIndex")
( ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "ifIndex")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
( RowStatus, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TruthValue")

# Objects

ciscoVlanMembershipMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 68)).setRevisions(("2007-12-14 00:00","2004-07-16 00:00","2004-04-07 00:00","2003-10-10 00:00","2003-06-05 00:00","2002-03-28 00:00","2001-05-01 00:00","2001-01-30 00:00","2000-01-06 00:00","1999-01-18 00:00","1996-12-06 00:00",))
if mibBuilder.loadTexts: ciscoVlanMembershipMIB.setOrganization("Cisco Systems Inc.")
if mibBuilder.loadTexts: ciscoVlanMembershipMIB.setContactInfo("Cisco Systems\nCustomer Service\n\nPostal: 170 W Tasman Drive\nSan Jose, CA  95134\nUSA\n\nTel: +1 800 553-NETS\n\nE-mail: cs-vlans@cisco.com")
if mibBuilder.loadTexts: ciscoVlanMembershipMIB.setDescription("The MIB module for the management of the VLAN\nMembership within the frame  work of Cisco\nVLAN Architecture, v 2.0 by Keith McCloghrie. The MIB\nprovides information on VLAN Membership Policy Servers\nused by a device and VLAN membership assignments of\nnon-trunk bridge ports of the device.")
ciscoVlanMembershipMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 1))
vmVmps = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1))
vmVmpsVQPVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVmpsVQPVersion.setDescription("The VLAN Query Protocol (VQP) version supported on\nthe device. VQP is the protocol used to query\nVLAN Membership Policy Server (VMPS) for VLAN\nmembership assignments of dynamic VLAN ports.\nA VMPS provides VLAN membership policy\nassignments based on the content of the packets\nreceived on a port.")
vmVmpsRetries = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVmpsRetries.setDescription("The number of retries for VQP requests to a VMPS before\nusing the next available VMPS.")
vmVmpsReconfirmInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 120)).clone(60)).setMaxAccess("readwrite").setUnits("Minutes")
if mibBuilder.loadTexts: vmVmpsReconfirmInterval.setDescription("The switch will reconfirm membership of addresses on\neach port with VMPS periodically. This object specifies\nthe interval to perform reconfirmation. If the value is\nset to 0, the switch does not reconfirm membership with\nVMPS.")
vmVmpsReconfirm = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("ready", 1), ("execute", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVmpsReconfirm.setDescription("Setting this object to execute(2) causes the switch\nto reconfirm membership of every dynamic port.\nReading this object always return ready(1).")
vmVmpsReconfirmResult = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(5,1,7,3,6,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("inProgress", 2), ("success", 3), ("noResponse", 4), ("noVmps", 5), ("noDynamicPort", 6), ("noHostConnected", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVmpsReconfirmResult.setDescription("This object returns the result of the last request\nthat sets vmVmpsReconfirm to execute(2). The\nsemantics of the possible results are as follows:\n\n     other(1)           - none of following\n     inProgress(2)      - reconfirm in progress\n     success(3)         - reconfirm completed successfully\n     noResponse(4)      - reconfirm failed because no\n                          VMPS responded\n     noVmps(5)          - No VMPS configured\n     noDynamicPort(6)   - No dynamic ports configured\n     noHostConnected(7) - No hosts on dynamic ports")
vmVmpsCurrent = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVmpsCurrent.setDescription("This is the IpAddress of the current VMPS used.")
vmVmpsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 7))
if mibBuilder.loadTexts: vmVmpsTable.setDescription("A table of VMPS to use. The device will use\nthe the primary VMPS by default. If the\ndevice is unable to reach the primary server\nafter vmVmpsRetries retries, it uses the first\nsecondary server in the table until it runs out\nof secondary servers, in which case it will return\nto using the primary server. Entries in this table\nmay be created and deleted via this MIB or\nthe management console on a device.")
vmVmpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 7, 1)).setIndexNames((0, "CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsIpAddress"))
if mibBuilder.loadTexts: vmVmpsEntry.setDescription("An entry (conceptual row) in the vmVmpsTable.")
vmVmpsIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 7, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVmpsIpAddress.setDescription("The Ip Address of the VMPS.")
vmVmpsPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 7, 1, 2), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vmVmpsPrimary.setDescription("The status of the VMPS. Setting this value\nto true will make this VMPS the primary server\nand make the switch use this as the current server.\nSetting this entry to true causes other rows\nto transition to false. Attempting to write\na value of false after creation will result in\na return of bad value. Deleting an entry whose\nvalue is true will result in the first entry\nin the table being set to true.")
vmVmpsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 1, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vmVmpsRowStatus.setDescription("The status of this conceptual row.")
vmMembership = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2))
vmMembershipSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 1))
if mibBuilder.loadTexts: vmMembershipSummaryTable.setDescription("A summary of VLAN membership of non-trunk\nbridge ports. This is a convenience table\nfor retrieving VLAN membership information.\n\nA row is created for a VLAN if:\na) the VLAN exists, or\nb) a port is assigned to a non-existent VLAN.\n\nVLAN membership can only be modified via the\nvmMembershipTable.")
vmMembershipSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 1, 1)).setIndexNames((0, "CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipSummaryVlanIndex"))
if mibBuilder.loadTexts: vmMembershipSummaryEntry.setDescription("An entry (conceptual row) in the\nvmMembershipSummaryTable.")
vmMembershipSummaryVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 1, 1, 1), VlanIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: vmMembershipSummaryVlanIndex.setDescription("The VLAN id of the VLAN.")
vmMembershipSummaryMemberPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMembershipSummaryMemberPorts.setDescription("The set of the device's member ports that belong\nto the VLAN.\n\nEach octet within the value of this object specifies a\nset of eight ports, with the first octet specifying ports\n1 through 8, the second octet specifying ports 9\nthrough 16, etc.   Within each octet, the most\nsignificant bit represents the lowest numbered\nport, and the least significant bit represents the\nhighest numbered port.  Thus, each port of the\nVLAN is represented by a single bit within the\nvalue of this object.  If that bit has a value of\n'1' then that port is included in the set of\nports; the port is not included if its bit has a\nvalue of '0'.\n\nA port number is the value of dot1dBasePort for\nthe port in the BRIDGE-MIB (RFC 1493).")
vmMembershipSummaryMember2kPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 1, 1, 3), CiscoPortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMembershipSummaryMember2kPorts.setDescription("The set of the device's member ports that belong\nto the VLAN. It has the VLAN membership information\nof up to 2048 ports with the port number from 1 to \n2048.\n\nEach octet within the value of this object specifies a\nset of eight ports, with the first octet specifying \nports 1 through 8, the second octet specifying ports 9\nthrough 16, etc.   Within each octet, the most\nsignificant bit represents the lowest numbered\nport, and the least significant bit represents the\nhighest numbered port.  Thus, each port of the\nVLAN is represented by a single bit within the\nvalue of this object.  If that bit has a value of\n'1' then that port is included in the set of\nports; the port is not included if its bit has a\nvalue of '0'.\n\nA port number is the value of dot1dBasePort for\nthe port in the BRIDGE-MIB (RFC 1493).")
vmMembershipTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2))
if mibBuilder.loadTexts: vmMembershipTable.setDescription("A table for configuring VLAN port membership.\nThere is one row for each bridge port that is\nassigned to a static or dynamic access port. Trunk\nports are not  represented in this table.  An entry\nmay be created and deleted when ports are created or\ndeleted via SNMP or the management console on a \ndevice.")
vmMembershipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: vmMembershipEntry.setDescription("An entry (conceptual row) in the vmMembershipTable.")
vmVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("static", 1), ("dynamic", 2), ("multiVlan", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVlanType.setDescription("The type of VLAN membership assigned to this port.\nA port with static vlan membership is assigned to a\nsingle VLAN directly. A port with dynamic membership\nis assigned a single VLAN based on content of packets\nreceived on the port and via VQP queries to VMPS.\nA port with multiVlan membership may be assigned to\none or more VLANs directly.\n\nA static or dynamic port membership is specified\nby the value of vmVlan. A multiVlan port membership is\nspecified by the value of vmVlans.")
vmVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVlan.setDescription("The VLAN id of the VLAN the port is assigned to\nwhen vmVlanType is set to static or dynamic.\nThis object is not instantiated if not applicable.\n\nThe value may be 0 if the port is not assigned\nto a VLAN.\n\nIf vmVlanType is static, the port is always\nassigned to a VLAN and the object may not be\nset to 0.\n\nIf vmVlanType is dynamic the object's value is\n0 if the port is currently not assigned to a VLAN.\nIn addition, the object may be set to 0 only.")
vmPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("inactive", 1), ("active", 2), ("shutdown", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmPortStatus.setDescription("An indication of the current VLAN status of the port.\nA status of inactive(1) indicates that a dynamic port\ndoes not yet have a VLAN assigned, or a port is \nassigned to a VLAN that is currently not active. A \nstatus of active(2) indicates that the currently \nassigned VLAN is active. A status of shutdown(3) \nindicates that the port has been disabled as a result\nof VQP shutdown response.")
vmVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVlans.setDescription("The VLAN(s) the port is assigned to when the\nport's vmVlanType is set to multiVlan.\nThis object is not instantiated if not applicable.\n\nThe port is always assigned to one or more VLANs\nand the object may not be set so that there are\nno vlans assigned.\n\nEach octet within the value of this object specifies a\nset of eight VLANs, with the first octet specifying\nVLAN id 1 through 8, the second octet specifying VLAN\nids 9 through 16, etc.   Within each octet, the most\nsignificant bit represents the lowest numbered\nVLAN id, and the least significant bit represents the\nhighest numbered VLAN id.  Thus, each VLAN of the\nport is represented by a single bit within the\nvalue of this object.  If that bit has a value of\n'1' then that VLAN is included in the set of\nVLANs; the VLAN is not included if its bit has a\nvalue of '0'.")
vmVlans2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVlans2k.setDescription("The VLAN(s) the port is assigned to when the\nport's vmVlanType is set to multiVlan.\nThis object is not instantiated if not applicable.\n\nThe port is always assigned to one or more VLANs\nand the object may not be set so that there are\nno vlans assigned.\n\nEach octet within the value of this object specifies a\nset of eight VLANs, with the first octet specifying\nVLAN id 1024 through 1031, the second octet specifying \nVLAN ids 1032 through 1039, etc.  Within each octet, \nthe most significant bit represents the lowest \nnumbered VLAN id, and the least significant bit \nrepresents the highest numbered VLAN id.  Thus, each \nVLAN of the port is represented by a single bit within\nthe value of this object.  If that bit has a value of\n'1' then that VLAN is included in the set of\nVLANs; the VLAN is not included if its bit has a\nvalue of '0'.")
vmVlans3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVlans3k.setDescription("The VLAN(s) the port is assigned to when the\nport's vmVlanType is set to multiVlan.\nThis object is not instantiated if not applicable.\n\nThe port is always assigned to one or more VLANs\nand the object may not be set so that there are\nno vlans assigned.\n\nEach octet within the value of this object specifies a\nset of eight VLANs, with the first octet specifying\nVLAN id 2048 through 2055, the second octet specifying \nVLAN ids 2056 through 2063, etc.   Within each octet, \nthe most significant bit represents the lowest \nnumbered VLAN id, and the least significant bit \nrepresents the highest numbered VLAN id.  Thus, each\nVLAN of the port is represented by a single bit within\nthe value of this object.  If that bit has a value of\n'1' then that VLAN is included in the set of\nVLANs; the VLAN is not included if its bit has a\nvalue of '0'.")
vmVlans4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVlans4k.setDescription("The VLAN(s) the port is assigned to when the\nport's vmVlanType is set to multiVlan.\nThis object is not instantiated if not applicable.\n\nThe port is always assigned to one or more VLANs\nand the object may not be set so that there are\nno vlans assigned.\n\nEach octet within the value of this object specifies a\nset of eight VLANs, with the first octet specifying\nVLAN id 3072 through 3079, the second octet specifying \nVLAN ids 3040 through 3047, etc.   Within each octet, \nthe most significant bit represents the lowest \nnumbered VLAN id, and the least significant bit \nrepresents the highest numbered VLAN id.  Thus, each\nVLAN of the port is represented by a single bit within\nthe value of this object.  If that bit has a value of\n'1' then that VLAN is included in the set of\nVLANs; the VLAN is not included if its bit has a\nvalue of '0'.")
vmMembershipSummaryExtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 3))
if mibBuilder.loadTexts: vmMembershipSummaryExtTable.setDescription("A summary of VLAN membership of non-trunk\nbridge ports. This table is used for \nretrieving VLAN membership information\nfor the device which supports dot1dBasePort \nwith value greater than 2048.\n\nA row is created for a VLAN and a particular\nbridge port range, where at least one port \nin the range is assigned to this VLAN.\n\nVLAN membership can only be modified via the\nvmMembershipTable.")
vmMembershipSummaryExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 3, 1)).setIndexNames((0, "CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipSummaryVlanIndex"), (0, "CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipPortRangeIndex"))
if mibBuilder.loadTexts: vmMembershipSummaryExtEntry.setDescription("An entry (conceptual row) in the\nvmMembershipSummaryExtTable.")
vmMembershipPortRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 3, 1, 1), CiscoPortListRange()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: vmMembershipPortRangeIndex.setDescription("The bridge port range index of this row.")
vmMembershipSummaryExtPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 3, 1, 2), CiscoPortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMembershipSummaryExtPorts.setDescription("The set of the device's member ports that belong\nto the VLAN. It has the VLAN membership information\nof up to 2k ports with the port number starting from\nthe information indicated in vmMembershipPortRangeIndex\nobject of the same row. For example, if the value\nof vmMembershipPortRangeIndex is 'twoKto4K', the\nport number indicated in this object starting from\n2049 and ending to 4096. \n\nA port number is the value of dot1dBasePort for\nthe port in the BRIDGE-MIB (RFC 1493).")
vmVlanCreationMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 2, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("automatic", 1), ("manual", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVlanCreationMode.setDescription("This object is used to determine whether or not\na non-existing VLAN will be created automatically\nby the system after assigned to a port.\n\nautomatic(1):  a non-existing VLAN will be created\n               automatically by the system after\n               assigned to a port.\n\nmanual(2):     a non-existing VLAN will not be created\n               automatically by the system and need to be\n               manually created by the users after assigned\n               to a port.")
vmStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3))
vmVQPQueries = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVQPQueries.setDescription("The total number of VQP requests sent by this device\nto all VMPS since last system re-initialization.")
vmVQPResponses = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVQPResponses.setDescription("The number of VQP responses received by this device\nfrom all VMPS since last system re-initialization.")
vmVmpsChanges = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVmpsChanges.setDescription("The number of times, since last system\nre-initialization, the current VMPS was changed. The\ncurrent VMPS is changed whenever the VMPS fails to \nresponse after vmVmpsRetries of a VQP request.")
vmVQPShutdown = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVQPShutdown.setDescription("The number of times, since last system\nre-initialization, a VQP response indicates \n'shutdown'. A 'shutdown' response is a result of \nthe membership policy configured at a VMPS\nby the administrator.")
vmVQPDenied = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVQPDenied.setDescription("The number of times, since last system\nre-initialization, a VQP response indicates \n'denied'. A 'denied' response is a result of \nthe membership policy configured at a VMPS\nby the administrator.")
vmVQPWrongDomain = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVQPWrongDomain.setDescription("The number of times, since last system\nre-initialization, a VQP response indicates wrong \nmanagement domain. A wrong management domain \nresponse indicates that the VMPS used serves a \nmanagement domain that is different\nfrom the device's management domain.")
vmVQPWrongVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmVQPWrongVersion.setDescription("The number of times, since last system\nre-initialization, a VQP response indicates wrong \nVQP version. A wrong VQP version response \nindicates that the VMPS used supports a VQP \nversion that is different from the device's \nVQP version.")
vmInsufficientResources = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmInsufficientResources.setDescription("The number of times, since last system\nre-initialization, a VQP response indicates \ninsufficient resources. An insufficient resources \nresponse indicates that the VMPS used does not \nhave the required resources to verify the\nmembership assignment requested.")
vmStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 4))
vmNotificationsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 4, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNotificationsEnabled.setDescription("An indication of whether the notifications/traps\ndefined in this MIB are enabled.")
vmVoiceVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 5))
vmVoiceVlanTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 5, 1))
if mibBuilder.loadTexts: vmVoiceVlanTable.setDescription("A table for configuring the Voice VLAN-ID\nfor the ports. An entry will exist for each\ninterface which supports Voice Vlan feature.")
vmVoiceVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 5, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: vmVoiceVlanEntry.setDescription("An entry (conceptual row) in the vmVoiceVlanTable.\nOnly interfaces which support Voice Vlan feature\nare shown.")
vmVoiceVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVoiceVlanId.setDescription("The Voice Vlan ID (VVID) to which this\nport belongs to.\n\n0    -    The CDP packets transmitting \n          through this port would contain\n          Appliance VLAN-ID TLV with value \n          of 0. VoIP and related packets \n          are expected to be sent and \n          received with VLAN-id=0 and an \n          802.1p priority. \n\n1..4094 - The CDP packets transmitting\n          through this port would contain\n          Appliance VLAN-ID TLV with N.\n          VoIP and related packets are\n          expected to be sent and received\n          with VLAN-id=N and an 802.1p\n          priority.\n\n4095  -   The CDP packets transmitting\n          through this port would contain\n          Appliance VLAN-ID TLV with value\n          of 4095. VoIP and related packets\n          are expected to be sent and \n          received untagged without an \n          802.1p priority.\n\n4096  -   The CDP packets transmitting \n          through this port would not \n          include Appliance VLAN-ID TLV; \n          or, if the VVID is not supported \n          on the port, this MIB object will\n          not be configurable and will \n          return 4096.")
vmVoiceVlanCdpVerifyEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 68, 1, 5, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmVoiceVlanCdpVerifyEnable.setDescription("Enable or Disable the feature of CDP message\nverification of voice VLANs.\n\ntrue   - The voice VLAN vmVoiceVlan is enabled \n         only after CDP messages are received \n         from the IP phone.\n\nfalse -  The voice VLAN vmVoiceVlan is enabled\n         as soon as the IP phone interface is\n         up. There is no verification needed \n         from CDP messages from the IP phone.")
vmNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 2))
vmNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 2, 0))
vmMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 3))
vmMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 1))
vmMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2))

# Augmentions

# Notifications

vmVmpsChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 68, 2, 0, 1)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsIpAddress"), ) )
if mibBuilder.loadTexts: vmVmpsChange.setDescription("A VMPS change notification is generated whenever\nvmVmpsChanges is incremented. The IP address\nof the new VMPS is sent.")

# Groups

vmMembershipGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 1)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlan"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipSummaryMemberPorts"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmPortStatus"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlanType"), ) )
if mibBuilder.loadTexts: vmMembershipGroup.setDescription("A collection of objects for displaying and\nconfiguring VLAN membership.")
vmVQPClientGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 2)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPWrongDomain"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsChanges"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsVQPVersion"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmInsufficientResources"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsRowStatus"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPWrongVersion"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPDenied"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPShutdown"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPQueries"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPResponses"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsReconfirmResult"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsRetries"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsIpAddress"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsPrimary"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsReconfirm"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsCurrent"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsReconfirmInterval"), ) )
if mibBuilder.loadTexts: vmVQPClientGroup.setDescription("A collection of objects for the managing a VQP\nclient.")
vmVQPNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 3)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVmpsChange"), ) )
if mibBuilder.loadTexts: vmVQPNotificationsGroup.setDescription("The notification group for a VQP client.")
vmStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 4)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmNotificationsEnabled"), ) )
if mibBuilder.loadTexts: vmStatusGroup.setDescription("A collection of objects for conveying general\nstatus information.")
vmMembershipGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 5)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlans"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlan"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipSummaryMemberPorts"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmPortStatus"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlanType"), ) )
if mibBuilder.loadTexts: vmMembershipGroup2.setDescription("A collection of objects for displaying and\nconfiguring VLAN membership.")
vm4kVlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 6)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlans3k"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlans4k"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlans2k"), ) )
if mibBuilder.loadTexts: vm4kVlanGroup.setDescription("A collection of objects providing multiVlan\ninformation for VLANS with VlanIndex from \n1024 to 4095 which are assigned to one port.")
vmVoiceVlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 7)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanId"), ) )
if mibBuilder.loadTexts: vmVoiceVlanGroup.setDescription("A collection of objects providing information\nof Voice Vlan feature.")
vm1kVlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 8)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlans"), ) )
if mibBuilder.loadTexts: vm1kVlanGroup.setDescription("A collection of objects providing multiVlan\ninformation for VLANS with VlanIndex from \n0 to 1023 which are assigned to one port.")
vmMembershipGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 9)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlan"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmPortStatus"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlanType"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipSummaryMember2kPorts"), ) )
if mibBuilder.loadTexts: vmMembershipGroup3.setDescription("A collection of objects for displaying and\nconfiguring VLAN membership.")
vmVoiceVlanExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 10)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanCdpVerifyEnable"), ) )
if mibBuilder.loadTexts: vmVoiceVlanExtGroup.setDescription("A collection of objects providing the\ninformation of CDP verification \nof Voice Vlan feature.")
vmMembershipExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 11)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipSummaryExtPorts"), ) )
if mibBuilder.loadTexts: vmMembershipExtGroup.setDescription("A collection of objects providing\ninformation for VLAN membership with \nbridge port ID greater than 2048.")
vmVlanCreationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 2, 12)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlanCreationMode"), ) )
if mibBuilder.loadTexts: vmVlanCreationGroup.setDescription("A collection of objects for the configuration\non VLAN creation mode when assigning a\nnon-existing VLAN to a port.")

# Compliances

vmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 1, 1)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPClientGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPNotificationsGroup"), ) )
if mibBuilder.loadTexts: vmMIBCompliance.setDescription("The   compliance   statement for   entities    which\nimplement the VLANs.")
vmMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 1, 2)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipGroup2"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPClientGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPNotificationsGroup"), ) )
if mibBuilder.loadTexts: vmMIBCompliance2.setDescription("The   compliance   statement for   entities    which\nimplement the VLANs.")
vmMIBCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 1, 3)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipGroup2"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vm4kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPClientGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPNotificationsGroup"), ) )
if mibBuilder.loadTexts: vmMIBCompliance3.setDescription("The   compliance   statement for   entities    which\nimplement the VLANs.")
vmMIBCompliance4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 1, 4)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vm1kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vm4kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmStatusGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPNotificationsGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPClientGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipGroup3"), ) )
if mibBuilder.loadTexts: vmMIBCompliance4.setDescription("The   compliance   statement for   entities    which\nimplement the VLANs.")
vmMIBCompliance5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 1, 5)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vm1kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vm4kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPClientGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmStatusGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipGroup3"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPNotificationsGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanExtGroup"), ) )
if mibBuilder.loadTexts: vmMIBCompliance5.setDescription("The   compliance   statement for   entities    which\nimplement the VLANs.")
vmMIBCompliance6 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 1, 6)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vm1kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vm4kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPClientGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmStatusGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipGroup3"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPNotificationsGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanExtGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipExtGroup"), ) )
if mibBuilder.loadTexts: vmMIBCompliance6.setDescription("The   compliance   statement for   entities    which\nimplement the VLANs.")
vmMIBCompliance7 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 68, 3, 1, 7)).setObjects(*(("CISCO-VLAN-MEMBERSHIP-MIB", "vm1kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vm4kVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPClientGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmStatusGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipGroup3"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVQPNotificationsGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVlanCreationGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmVoiceVlanExtGroup"), ("CISCO-VLAN-MEMBERSHIP-MIB", "vmMembershipExtGroup"), ) )
if mibBuilder.loadTexts: vmMIBCompliance7.setDescription("The   compliance   statement for   entities    which\nimplement the VLANs.")

# Exports

# Module identity
mibBuilder.exportSymbols("CISCO-VLAN-MEMBERSHIP-MIB", PYSNMP_MODULE_ID=ciscoVlanMembershipMIB)

# Objects
mibBuilder.exportSymbols("CISCO-VLAN-MEMBERSHIP-MIB", ciscoVlanMembershipMIB=ciscoVlanMembershipMIB, ciscoVlanMembershipMIBObjects=ciscoVlanMembershipMIBObjects, vmVmps=vmVmps, vmVmpsVQPVersion=vmVmpsVQPVersion, vmVmpsRetries=vmVmpsRetries, vmVmpsReconfirmInterval=vmVmpsReconfirmInterval, vmVmpsReconfirm=vmVmpsReconfirm, vmVmpsReconfirmResult=vmVmpsReconfirmResult, vmVmpsCurrent=vmVmpsCurrent, vmVmpsTable=vmVmpsTable, vmVmpsEntry=vmVmpsEntry, vmVmpsIpAddress=vmVmpsIpAddress, vmVmpsPrimary=vmVmpsPrimary, vmVmpsRowStatus=vmVmpsRowStatus, vmMembership=vmMembership, vmMembershipSummaryTable=vmMembershipSummaryTable, vmMembershipSummaryEntry=vmMembershipSummaryEntry, vmMembershipSummaryVlanIndex=vmMembershipSummaryVlanIndex, vmMembershipSummaryMemberPorts=vmMembershipSummaryMemberPorts, vmMembershipSummaryMember2kPorts=vmMembershipSummaryMember2kPorts, vmMembershipTable=vmMembershipTable, vmMembershipEntry=vmMembershipEntry, vmVlanType=vmVlanType, vmVlan=vmVlan, vmPortStatus=vmPortStatus, vmVlans=vmVlans, vmVlans2k=vmVlans2k, vmVlans3k=vmVlans3k, vmVlans4k=vmVlans4k, vmMembershipSummaryExtTable=vmMembershipSummaryExtTable, vmMembershipSummaryExtEntry=vmMembershipSummaryExtEntry, vmMembershipPortRangeIndex=vmMembershipPortRangeIndex, vmMembershipSummaryExtPorts=vmMembershipSummaryExtPorts, vmVlanCreationMode=vmVlanCreationMode, vmStatistics=vmStatistics, vmVQPQueries=vmVQPQueries, vmVQPResponses=vmVQPResponses, vmVmpsChanges=vmVmpsChanges, vmVQPShutdown=vmVQPShutdown, vmVQPDenied=vmVQPDenied, vmVQPWrongDomain=vmVQPWrongDomain, vmVQPWrongVersion=vmVQPWrongVersion, vmInsufficientResources=vmInsufficientResources, vmStatus=vmStatus, vmNotificationsEnabled=vmNotificationsEnabled, vmVoiceVlan=vmVoiceVlan, vmVoiceVlanTable=vmVoiceVlanTable, vmVoiceVlanEntry=vmVoiceVlanEntry, vmVoiceVlanId=vmVoiceVlanId, vmVoiceVlanCdpVerifyEnable=vmVoiceVlanCdpVerifyEnable, vmNotifications=vmNotifications, vmNotificationsPrefix=vmNotificationsPrefix, vmMIBConformance=vmMIBConformance, vmMIBCompliances=vmMIBCompliances, vmMIBGroups=vmMIBGroups)

# Notifications
mibBuilder.exportSymbols("CISCO-VLAN-MEMBERSHIP-MIB", vmVmpsChange=vmVmpsChange)

# Groups
mibBuilder.exportSymbols("CISCO-VLAN-MEMBERSHIP-MIB", vmMembershipGroup=vmMembershipGroup, vmVQPClientGroup=vmVQPClientGroup, vmVQPNotificationsGroup=vmVQPNotificationsGroup, vmStatusGroup=vmStatusGroup, vmMembershipGroup2=vmMembershipGroup2, vm4kVlanGroup=vm4kVlanGroup, vmVoiceVlanGroup=vmVoiceVlanGroup, vm1kVlanGroup=vm1kVlanGroup, vmMembershipGroup3=vmMembershipGroup3, vmVoiceVlanExtGroup=vmVoiceVlanExtGroup, vmMembershipExtGroup=vmMembershipExtGroup, vmVlanCreationGroup=vmVlanCreationGroup)

# Compliances
mibBuilder.exportSymbols("CISCO-VLAN-MEMBERSHIP-MIB", vmMIBCompliance=vmMIBCompliance, vmMIBCompliance2=vmMIBCompliance2, vmMIBCompliance3=vmMIBCompliance3, vmMIBCompliance4=vmMIBCompliance4, vmMIBCompliance5=vmMIBCompliance5, vmMIBCompliance6=vmMIBCompliance6, vmMIBCompliance7=vmMIBCompliance7)